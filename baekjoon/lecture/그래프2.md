# 그래프 2

## DAG(Directed Acyclic Graph)

- 사이클이 없는 방향 있는 그래프 

![](https://www.statisticshowto.datasciencecentral.com/wp-content/uploads/2016/04/directed-acyclic-graph.png)

- 사이클이 없기 때문에 몇몇 특수한 그래프 알고리즘들을 적용할수있음.
- 그중 하나가 위상 정렬

### 위상정렬

- 어떤 일을 하는 순서를 찾는 알고리즘.
- 자신을 가리키는 정점들이 모두 처리되어야 처리할수있다.
  - 예를들어 저기서 5번 정점을 처리할려면 2번과 6번이 완료되어야한다.
- 이러한 조건들이 있을때 순서를 찾는 알고리즘이 위상정렬.
- 알고리즘
  - 들어오는 정점의 개수가 (indegree) 0이 되는것부터 큐에 넣음.
  - 큐에 정점을 하나씩 꺼내고 가리키는 정점들의 indegree를 1 감소시키고 0이라면 큐에 넣는다.
  - 이걸 큐가 빌때까지 하면 댐.
  - bfs와 꽤 유사함
  - 2252번 코드 참고
  - 큐를 우선순위 큐로 바꾸면 가장 사전순(?) 암튼 작은 순서대로 할수잇음.
    - 1766번 코드 참고.

- bfs비슷하게 쓰면 대는 알고리즘인듯

### 1948- 임계경로

- 작업(2056)과 비슷하게 가장 긴 경로를 구해주면 댐.
  - 다만 그 경로를 모두 구해야한다는것이 좀 어려울수있음.
- 따라서 먼저 가장 긴 경로의 값을 구해주고 경로를 모두 반대로 만들어서 역으로 추적해나가는 방식으로 구현해보자.
- 즉, 먼저 시작점에서 위상정렬 돌리고 다시 거꾸로 돌려보자.
- 자세한건 코드참고

## MST

- 스패닝 트리: 그래프에서 일부 간선을 선택해서 만든 트리.
  - 모든 정점이 연결되어있어야함.
  - 따라서 모든 정점을 n-1개의 간선으로 연결함.
- 최소 스패닝 트리(MST): 스패닝 트리 중에 선택한 간선의 가중치의 합이 최소인 트리.
- 스패닝 트리의 장점은 그래프에서 있던 간선만 사용하기 때문에 연결 상태가 유지된다는 장점을 가지고있음.
- 프림, 크루스칼이 최소 스패닝 트리를 찾는 알고리즘.
  - 프림: MST에 포함되는 '정점'을 점점 확장해나가는 방식
  - 크루스칼: MST에 포함되는 '간선'을 점점 확장해나가는 방식

### 프림 알고리즘

- 알고리즘
  1. 그래프에서 아무 정점이나 선택한다.
  2. 선택한 정점과 선택하지 않은 정점을 연결하는 간선중에 최소값을 고른다. 이 간선을 (u,v)라고 한다.(u= 선택, v = 선택하지 않음.)
  3. 선택한 간선을 MST에 추가하고 v를 선택
  4. 모든 정점을 탐색하지 않았다면 2번단계로 돌아간다.
- 힙을 사용하여 최소값을 쉽게 구할수있음.
  - 힙에 (정점번호, 가중치)를 넣고 쓰면댐.
  - 힙에서 뽑았을때 이미 선택된 정점이 있으면 무시하면 댐.
- O(ElgE) - 모든 간선이 한번씩 힙에 들어갔다 나오기 때문
- 구현은 1922번 코드 참고

### 크루스칼

- Union-find를 이용
  - https://code.plus/board/6/view/578?prev=2
- 가중치가 낮은 간선부터 탐색.(따라서 탐색이 먼저 되어야함.)
- Edge e가 (u,v,c)일때 u와 v가 다른 집합이면 e를 MST에 추가.
- 1197번 코드 참고
- 개인적으로 구현이 간단하고 직관적이여서 마음이 든다.

### 그래서 둘 중에서 뭐가 더 좋아요?

- https://eehoeskrap.tistory.com/39
- https://stackoverflow.com/questions/1195872/when-should-i-use-kruskal-as-opposed-to-prim-and-vice-versa
- 그렇다고 한다

## 최단경로(시작점이 1개일때)

- 최단거리 알고리즘을 2가지로 분류할수있음.. 정점이 V가 있을때,
  - 시작점이 1개일때
  - 시작점이 V개일때
- 먼저 1개일때를 알아보자
- A->B로 가는 최단 경로는 최대 N-1개의 간선으로 이루어져있다.
  - 같은 정점을 다시 방문할일이 없기 때문이다.

### 벨만 포드 알고리즘

- 최단 경로는 최대 N-1개의 간선으로 이루어져있다를 응용한 알고리즘.(한점-다수의점)

- 한 정점에서 다른 모든 정점에 대하여 최단 경로를 구함.

- from->to 이고 가중치가 cost일때

- dist[i]=시작점에서 i로 가는 최단 거리라고 할때

  ```
  if(dist[to]>dist[from]+cost) {
  	dist[to] = dist[from] + cost;
  }
  ```

  이렇게 바꿔주는것이 다익스트라와 벨만 포드의 핵심임. 즉, from을 거쳐서 가는게 from을 안거쳐서 가는것보다 더 빠르다는것을 의미함.

- 벨만은 위 식을 V-1번 검사함. 왜냐면 간선이 최대 V-1개이기 때문.

  - 다익스트라는 모든 간선에 대하여 식을 1번만 검사함.

- 알고리즘

  1. 모든 간선 e (u,v,c)에 대하여 다음을 검사한다.
     - dist[v] = min(dist[v], dist[u] + c);

  - 1번 과정을 총 n-1번 반복.

- 처음엔 dist배열을 모두 졸라 큰값(무한대)로 바꿔야함.

- O(VE)인데 E <= E^2이기때문에 O(V^3)

- **음수 가중치에서도 사용할수있음.(다익스트라는 불가능)**

  - 음수가중치는 최단 경로가 존재하지 않을수도 있어서임.
    - 음수 사이클이 존재하는 경우

- **벨만포드는 음수 사이클이 존재하는 경우를 체크할수있음.**

  - V-1번을 돌리면 최단 경로가 구해진것이기 때문에 그 이상 돌려도 값은 바뀌지 않을것임.
  - 그런데 음수 사이클이 존재하면 돌때마다 계속 낮아지니까 벨만포드 돌리고 한번 더 돌렸을때 달라지면 이는 최단경로가 없고 음수 사이클이 존재한다는 이야기임.

- 11657코드에 음의 사이클탐지와 벨만포드 코드가 있음.

  - 겉의 for문 횟수가 한번 더 늘었는데 이건 사이클 탐지할려고
  - 따라서 최단경로만 구하려면 루프 횟수를 한번 줄이면 댐.

- 모든 정점과 모든 간선을 다 탐색해보기때문에 인접리스트같은거 안만들고 존내 돌려주면 댐.

  - 보통 인접행렬이나 인접리스트는 어떤 정점과 연결된 간선들을 효율적으로 하기위한 자료구조이기 때문
  - 근데 얘는 걍 모든 정점과 모든 간선을 다 존내 돌려보는거라서 필요가 없음.

### 다익스트라

- 벨만포드와 같이 한 정점에서 다른 모든 정점에 대하여 최단 경로를 구함.(한점-다수의점)
- 벨만포드는 N-1번 식을 검사하지만 다익스트라는 1번
- 음수일때 동작을 안함
- D[i] = 시작점에서 i번째 정점까지의 최단거리, C[i] = i를 방문했었으면 true 아니면 false
- 알고리즘
  1. 체크되어있지 않은 정점중 D의 값이 가장 작은 정점 x를 선택.
  2. x를 체크
  3. x와 연결된 모든 정점 체크
     - 간선을 (u,v,c)라고 할때 d[v] > d[u] + c라면 갱신
  4. 1,2,3을 모든 정점을 다 체크할때까지 반복.
- O(V^2)
- 우선순위 큐 써서 구현할수도 있음. 더 빠를거임.1753번 참고
  - https://www.crocus.co.kr/546 여기 구현은 체크배열이 필요없음

### 플로이드 워셜

- 모든 쌍의 최단경로를 찾는 알고리즘
- 코드가 존나 간단함.

```
for(int k = 1; k <= n; k++) {
	for(int i=1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			if(d[i][j] > d[i][k] + d[k][j]) {
				d[i][j] = d[i][k] + d[k][j];
			}
		}
	}
}
```

- 11780코드보면 경로를 추적하는데 v\[i][j]를 i와 j사이의 간선이 가리키는곳이라고 하고 v\[i][j] = v\[i][k]라고 하면 댐.

### SPFA

- 벨만포드를 조금 빠르게 한것.
- 최악의 경우는 O(VE)지만 평균적으로 O(E)
- 벨만포드와 아이디어는 비슷한데 변을 모두 검사하는게 아님.
  - from -> to로 검사했는데 dist[to]값이 안바뀌었다면 나중에 to가 from, 즉 to에서 탐색할때의 to값도 변경될일이 없다.
  - 즉, 업데이트 되는 정점과 연결된 간선만 업데이트를 진행함.
- 그러한 이유로 인접리스트를 구현해야함. 간선을 효율적으로 검색해야하기 때문.
- 바뀐 정점은 큐를 이용해 관리하고 큐에 들어가있는지 안들어가있는지를 배열을 이용해 체크해준다.

```c++
for (int i=1; i<=n; i++) {
    d[i] = inf;
}
d[1] = 0;
queue<int> q;
q.push(1);
c[1] = true;
while (!q.empty()) {
    int from = q.front();
    c[from] = false; q.pop();
    for (Edge &e : a[from]) {
        int to = e.to, cost = e.cost;
        if (d[to] > d[from] + cost) {
            d[to] = d[from] + cost;
            if (c[to] == false) {
            		q.push(to);
                c[to] = true;
            }
          } 			
       }
 }
```

1. 큐에 시작점 넣고 큐에 들어갔다고 체크.(중복으로 들어가서 처리하는경우를 해결하기 위함일듯.)
2. 큐가 빌때까지
   1. 큐에서 정점 꺼내고 체크 풀기
   2. 연결된 모든 정점에 대하여 업데이트 후 체크가 안되어있으면 그 정점을 큐에 넣고 체크.

- 모든 정점이 큐에 최대 V-1번 들어갈수있음.

- MCMF 알고리즘을 쓸때 주로 사용한다고함.

- 얘로 음수사이클 체크하는 코드는

  - https://gist.github.com/Baekjoon/f50cd9501baec1064eec

  - ![](https://t1.daumcdn.net/cfile/tistory/271F3A38595F7DF51C)
  - 