# 백준 - 완전탐색 1

## 완전탐색?

- 가능한 모든 경우를 다 해보는거
- 당연히 모든 경우를 다 해보려면 모든 경우를 알아야함.
  - 그리고 경우의 수를 알아야 이게 불가능한지 가능한지를 알수있음.
- 방법
  - Brute force
    - 모든 경우의 수에 대한 파악이 되어있어야댐. 안그러면 터짐 ㅋ
  - BFS - graph로 나타내서 조지기
    - 상태를 잘 표현하고 그 사이의 전이를 잘 표현해야 잘 풀수있음. 그리고 가중치가 1인지 꼭 확인할것.
    - 상태의 개수 적어야함. BFS의 시간복잡도는 정점의 개수에 비례하니까.
    - 최소를 구하는 문제여야함. - BFS는 최단경로를 구하는 알고리즘이니까.
    - 상태와 상태를 연결하는 간선의 가중치는 모두 1이 나와야함.(그래야 bfs가 최단경로를 구하는 알고리즘이 되니까.)
    - 식을 정리해서 변수같은걸 줄여주든 뭘 하든 상태를 줄일수있는 방법이 있으면 줄이면 좋다.(2251번처럼)
  - Bitmask - 부분집합을 다룰때
  - Permutation - 모든 경우를 탐색하긴 해야하는데 순서를 바꿔주면서 탐색하는 경우
    - n > 10이면 수가 졸라 커져서 문제풀기 힘듬
    - 따라서 제한이 보통 n <= 10인 경우가 많음.
    - 맨 처음 수열은 오름차순이기때문에 정렬하고 탐색 시작하셈
  - 백트래킹
    - 다음 재귀 호출 전에 상태를 세팅하고 재귀호출이 완료되면 다시 상태를 원상복귀 하는것이 중요.
    - 그리고 인자 레퍼런스 안붙여주면(벡터같은거) 메모리 좆댐 레퍼런스 꼭 붙여주자. 재귀함수 쓰는건 다 그렇게 해야댐.
- 벡터의 size를 사용할때는 -1이 들어가는 표현식은 웬만하면 쓰지말자.
  - size = 0일때 size의 자료형은 unsigned이기 때문에 -1이 아닌 존내 큰값이 나와서 존내크게 루프를 돌아버림.
  - 따라서 int 캐스팅 또는 -1이 들어가지 않는 표현식을 사용하는것이 좋다!



## 외판원 순회 2

- 이거 시간복잡도 단축하려면 출발 도시를 고정시키면 댐.
  - 잘 보면 n=4일때,
    - 1->2->3->4
    - 2->3->4->1
    - 3->4->1->2
    - 4->1->2->3
    - 위 4가지 경로는 모두 같은것임. 왜냐하면 시작도시로 돌아오라는 조건이 있으니까 원순열마냥 돌려주면 결국은 다 같은 순열임.
    - 따라서 시작 위치를 1로 고정시키고 나머지 n-1개에 대해서만 팩토리얼을 돌려버리면 댐.
    - 이렇게 원순열을 이용해서 O(N*N!)이 나올 알고리즘을 O(N!)으로 바꿔버릴수있음. holy shit
  - 그래서 next_permuation(d.begin()**+1**, d.end())인거임.
- 집합에 같은 원소가 있을때 그 집합의 순열의 개수는? 
  - {1,1,2,2,2}가 있을때는 1이 2개, 2가 3개이므로 5! / (2!3!) 개.
  - 이렇게 원소 x가 a개, 원소 y가 b개, 원소 z가 c개 … 이런식으로 있고 x + y + z + .. = n일때 순열의 개수는
    - n! / (a!b!c!,,)개가 된다!

## 퍼즐(1525)

- 상태를 배열로 표현할수없음.(2차원 배열)
  - Fact1. 2차원 배열은 1차원 배열로 표현가능
- 따라서 다음 두가지 전략을 생각해볼수있음.
  1. 같은수가 없기 때문에 순열로 생각하여  몇번째 순열인지 저장하자.
     - 1727번 응용? 1722번 아닌가?
  2. **map을 사용한다.**
     - 빈 자리에(0을) 9를 추가하면 항상 9자리 정수가 나오기때문에 이를 이용하자.



재귀함수로 전체탐색 - 재귀함수를 잘~ 설계하면 댐

- 탈출조건(불가능한 경우, 탐색을 완료한 경우)
- 다음 경우

## N-Queen

- 현재 함수에 따라서 다음 함수에서 할수있는것들이 바뀜
  - 따라서 상태를 바꾸고 돌아오면 다시 상태를 돌려주는것이 중요.
- 이것이 백트래킹이다.
- 열 검사할때 개무식하게 하지말고 대각선이랑 열 체크하는 check배열 만들어서 해보셈.
  - O(n^n^2)에서 O(n^n)으로 가능.
  - 9963_improved참고해보셈. 저런 대각선 다룰때 x + y의 값을 이용하면 /방향 대각선 배열을 만들수있음. x+y의 값이 같으면 같은 대각선에 속한것. 마찬가지로 (x-y) + n은 \방향 대각선.



## 스도쿠

- 코드에서 go함수에서 z라는 변수 하나만을 이용해서 x,y를 표현할수있고 다음 칸으로 이동하는건 z +1을 하는식으로 구현한거 비슷한 상황에서 써먹기 좋음. 변수 줄이는건 좋지.
- 답 도출할때 전역변수 쓰지 말고 함수가 값을 리턴하게 해주는게 좋음.